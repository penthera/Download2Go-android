/*
    Created by Penthera on 19/03/21.
    Copyright Â© 2021 Penthera. All rights reserved.

    This source file contains a very basic example showing how to use the Penthera Download2Go SDK.
    Pay close attention to code comments marked IMPORTANT
*/
package com.penthera.download2goandroidx;

import androidx.appcompat.app.AppCompatActivity;
import androidx.lifecycle.LiveData;

import android.os.Bundle;
import android.view.View;
import android.widget.Button;
import android.widget.ProgressBar;
import android.widget.TextView;
import android.widget.Toast;

import com.penthera.virtuososdk.Common;
import com.penthera.common.Common.AuthenticationStatus;
import com.penthera.virtuososdk.androidxsupport.SegmentedAssetLiveData;
import com.penthera.virtuososdk.androidxsupport.VirtuosoLiveDataFactory;
import com.penthera.virtuososdk.client.IAsset;
import com.penthera.virtuososdk.client.ISegmentedAsset;
import com.penthera.virtuososdk.client.ISegmentedAssetFromParserObserver;
import com.penthera.virtuososdk.client.Virtuoso;
import com.penthera.virtuososdk.client.builders.HLSAssetBuilder;

import java.net.MalformedURLException;
import java.net.URL;
import java.util.UUID;

import static com.penthera.virtuososdk.client.SegmentedParserError.NO_ERROR;

public class MainActivity extends AppCompatActivity {

    // DEMO Server details
    private static final String BACKPLANE_PUBLIC_KEY = ;
    private static final String BACKPLANE_PRIVATE_KEY = ;

    // This is the test asset which will be downloaded
    // Important: Asset ID should be unique across your video catalog
    private static final String ASSET_ID = "TEST_ASSET_ID";
    private static final String ASSET_TITLE = "TEST ASSET";
    private static final String ASSET_URL = "https://virtuoso-demo-content.s3.amazonaws.com/Steve/steve.m3u8";

    private VirtuosoLiveDataFactory virtuosoLiveDataFactory;
    private Virtuoso virtuoso;
    private IAsset asset = null;
    private SegmentedAssetLiveData segmentedAssetLiveData = null;

    // The three buttons
    private Button dlBtn;
    private Button plBtn;
    private Button delBtn;

    private TextView textView;
    private TextView statusView;
    private ProgressBar progressBar;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        virtuosoLiveDataFactory = VirtuosoLiveDataFactory.getInstance();
        virtuoso = virtuosoLiveDataFactory.createVirtuosoWithLifecycle(this, this);

        LiveData<Integer> engineStatus = virtuosoLiveDataFactory.getEngineStatus();
        engineStatus.observe(this, statusVal -> {
            statusView.setText(getString(R.string.engine_status, getStatusString(statusVal)));
        });

        dlBtn = findViewById(R.id.download);
        plBtn = findViewById(R.id.play);
        delBtn = findViewById(R.id.delete);
        textView = findViewById(R.id.textView);
        statusView = findViewById(R.id.engineStatusView);
        progressBar = findViewById(R.id.progressBar);

        dlBtn.setOnClickListener(v -> downloadAsset());
        plBtn.setOnClickListener(v -> playAsset());
        delBtn.setOnClickListener(v -> deleteAsset());

        updateUI();
    }

    public void initVirtuosoSDK() {
        // This is current best practice for initializing the SDK
        int status = virtuoso.getBackplane().getAuthenticationStatus();
        if (status != AuthenticationStatus.AUTHENTICATED) { // If not authenticated then execute sdk startup

            // Here we use the simplest login with hard coded values
            // This starts the SDK by registering it with the backplane. It is asynchronous. Success can be observed using the IEngineObserver interface.
            virtuoso.startup(
                    UUID.randomUUID().toString(),    // provide an appropriate unique user id. A random uuid is used here for demonstration purposes only
                    null,                                           // Optional additional device id to be associated with the user account. This is not the device id generated by the SDK
                    BACKPLANE_PUBLIC_KEY,                               // Substitute the real public backplane key here
                    BACKPLANE_PRIVATE_KEY,                              // Substitute the real private backplane key here
                    null                         // Push registration callback, this will be detailed in subsequent tutorials.
                    // This callback does not indicate that SDK startup is complete
            );
        }

        // Load asset if it has already been downloaded
        loadAsset();
    }

    // In a large application this would be encapsulated within a ModelView
    private void loadAsset() {
        if (segmentedAssetLiveData != null) {
            segmentedAssetLiveData.removeObservers(this);
        }
        segmentedAssetLiveData = virtuosoLiveDataFactory.getAssetStatus(ASSET_ID);
        segmentedAssetLiveData.observe(this, updatedAssetVal -> {
            asset = updatedAssetVal;
            updateAssetUI();
        });
    }

    private void updateUI() {
        dlBtn.setEnabled(asset == null);
        plBtn.setEnabled(asset != null);
        delBtn.setEnabled(asset != null);

        if (asset == null) {
            textView.setText("");
        }
    }

    private void downloadAsset() {
        initVirtuosoSDK();

        URL assetUrl;
        try {
            assetUrl = new URL(ASSET_URL);
        } catch (MalformedURLException mue) {
            Toast.makeText(this, "Problem with asset URL", Toast.LENGTH_LONG).show();
            return;
        }

        // Creation of assets follows a builder pattern.
        // Create the parameters for the new asset.
        HLSAssetBuilder.HLSAssetParams params = new HLSAssetBuilder()
                .assetId(ASSET_ID)          // REQUIRED PARAMETER unique asset ID of the new asset
                .manifestUrl(assetUrl)
                .assetObserver(new AssetParseObserver(this))
                .addToQueue(true)
                .desiredVideoBitrate(Integer.MAX_VALUE)
                .withMetadata(ASSET_TITLE)
                .build();

        // Add to the SDK
        virtuoso.getAssetManager().createHLSSegmentedAssetAsync(params);

        loadAsset();
    }

    private void playAsset() {
        if (asset != null) {
            VideoPlayerActivity.playVideoDownload(this, asset);
        }
    }

    private void deleteAsset() {
        virtuoso.getAssetManager().delete(asset);
        asset = null;
    }

    /**
     * A simple method to demonstrate updating the basic details of the asset into the UI.
     */
    private void updateAssetUI() {

        int progress = -1;
        String assetStatus = "";
        String value = "";
        long errorCount = 0;

        if (asset != null) {
            // Calculate progress as a percentage
            progress = (int) (asset.getCurrentSize() / asset.getExpectedSize() * 100); // Sizes in doubles, percentage cast to an int for reporting

            // Keep context switches minimal due to frequency of messages, unless forced
            int downloadStatus = asset.getDownloadStatus();


            switch (downloadStatus) {
                case Common.AssetStatus.DOWNLOADING:
                    assetStatus = getString(R.string.status_downloading);
                    value = getString(R.string.asset_status_downloading);
                    break;

                case Common.AssetStatus.DOWNLOAD_COMPLETE:
                    assetStatus = getString(R.string.status_downloaded);
                    value = getString(R.string.asset_status_complete);
                    break;

                case Common.AssetStatus.EXPIRED:
                    assetStatus = getString(R.string.status_expired);
                    value = getString(R.string.asset_status_expired);
                    break;

                case Common.AssetStatus.DOWNLOAD_DENIED_ASSET:
                    assetStatus = getString(R.string.status_queued);
                    value = getString(R.string.asset_status_denied_mad);
                    break;

                case Common.AssetStatus.DOWNLOAD_DENIED_ACCOUNT:
                    assetStatus = getString(R.string.status_queued);
                    value = getString(R.string.asset_status_denied_mda);
                    break;

                case Common.AssetStatus.DOWNLOAD_DENIED_EXTERNAL_POLICY:
                    assetStatus = getString(R.string.status_queued);
                    value = getString(R.string.asset_status_denied_ext);
                    break;

                case Common.AssetStatus.DOWNLOAD_DENIED_MAX_DEVICE_DOWNLOADS:
                    assetStatus = getString(R.string.status_queued);
                    value = getString(R.string.asset_status_denied_mpd);
                    break;

                case Common.AssetStatus.DOWNLOAD_DENIED_COPIES:
                    assetStatus = getString(R.string.status_queued);
                    value = getString(R.string.asset_status_denied_copies);
                    break;

                case Common.AssetStatus.DOWNLOAD_BLOCKED_AWAITING_PERMISSION:
                    assetStatus = getString(R.string.status_queued);
                    value = getString(R.string.asset_status_await_permission);
                    break;

                default:
                    assetStatus = getString(R.string.status_pending);
                    value = getString(R.string.asset_status_pending);
            }

            errorCount = asset.getErrorCount();
        }

        updateUI();
        textView.setVisibility(View.VISIBLE);
        textView.setText(getString(R.string.asset_status, assetStatus, errorCount, value));

        // Show a small amount of progress on bar
        if (progress == 0) {
            progress = 1;
        }

        if (progress > 0 && progress < 99) {
            progressBar.setVisibility(View.VISIBLE);
            progressBar.setProgress(progress);
        } else {
            progressBar.setVisibility(View.GONE);
        }
    }

    static class AssetParseObserver implements ISegmentedAssetFromParserObserver {

        private AppCompatActivity activity;

        public AssetParseObserver(AppCompatActivity activity) {
            this.activity = activity;
        }

        @Override
        public void complete(final ISegmentedAsset asset, int error, boolean addedToQueue) {
            activity.runOnUiThread(() -> {
                if(asset != null && error == NO_ERROR) {
                    Toast.makeText(activity, "Asset parsed and " + (addedToQueue ? "added" : "not added") + " to download queue", Toast.LENGTH_LONG  ).show();
                }
                else{
                    Toast.makeText(activity, "Error " + error + " while parsing asset", Toast.LENGTH_LONG).show();
                }
            });
        }
    }

    private String getStatusString(int engineStatus) {
        String status;
        switch (engineStatus) {
            case Common.EngineStatus.DOWNLOADING:
                status = "Downloading";
                break;
            case Common.EngineStatus.PAUSED:
                status = "Paused";
                break;
            case Common.EngineStatus.DISABLED:
                status = "Download Disabled";
                break;
            case Common.EngineStatus.BLOCKED:
                status = "Blocked";
                break;
            case Common.EngineStatus.ERROR:
                status = "Errored";
                break;
            case Common.EngineStatus.AUTH_FAILURE:
                status = "Auth Failure";
                break;
            case Common.EngineStatus.IDLE:
            default:
                status = "Idle";
        }
        return status;
    }
}
